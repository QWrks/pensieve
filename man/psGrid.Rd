% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/psGrid.R
\name{psGrid}
\alias{psGrid}
\alias{validate_S3.psGrid}
\alias{as_psGrid}
\alias{as_psGrid.integer}
\alias{as_psGrid.numeric}
\alias{as_psGrid.matrix}
\alias{as_psGrid.psSort}
\alias{knit_print.psGrid}
\title{Store sorting grid as logical matrix.}
\usage{
psGrid(grid, polygon = "rectangle", offset = NULL)

\method{validate_S3}{psGrid}(x, ...)

as_psGrid(obj, ...)

\method{as_psGrid}{integer}(obj, ...)

\method{as_psGrid}{numeric}(obj, ...)

\method{as_psGrid}{matrix}(obj, ...)

\method{as_psGrid}{psSort}(obj, ...)

\method{knit_print}{psGrid}(x, header = TRUE, footer = TRUE,
  aspect_ratio_cards = 85/54, inline = FALSE, ...)
}
\arguments{
\item{grid}{\code{[matrix()]}
giving the availability of cells for sorting as \code{logical(1)} values.
The (horizontal) x-axis is assumed to be the sorting direction, the (vertical) y-axis for recording ties.
Dimensions can be named (recommended), giving a short description of the sorting dimension (only applicable to the x-axis).
Row and column \emph{indeces} can also be named, but names are purely cosmetic.}

\item{polygon}{\code{[character(1)]} giving polygon to use for tiling

Must be one of:
\itemize{
\item \code{'rectangle'} (\strong{default}) or
\item \code{'hexagon'}
}}

\item{offset}{\code{[character(1)]} giving the \emph{rows} to be offset.

Must be one of:
\itemize{
\item \code{NULL} in which case no offset is used for a square tiling. (\strong{default})
\item \code{'even'} or
\item \code{'odd'}
}}

\item{x}{An object with one of the pensieve S3 classes.}

\item{...}{further arguments to be passed to methods.}

\item{obj}{An object which can be coerced to a logical matrix of class \link{psGrid}, currently one of:
\itemize{
\item a (named) integer(ish) vector, giving the column height of \code{TRUE}s from the bottom (names are retained as column names),
\item a logical matrix as per \link{psGrid} and
\item a character matrix as per \link{psSort} (sets all cells to \code{TRUE})
}}

\item{header, footer}{A logical flag, defaults to \code{TRUE}, in which case column or row names from \code{grid} are included as headers or footers, respectively.
Missing row or column names are replaced with sensible defaults.}

\item{aspect_ratio_cards}{A numeric scalar, giving width divided by height of \emph{individual cards} (such as 16/9 for screen dimensions).
Aspect ratio of \emph{cards} is required to appropriately set the resulting dimensions of the \emph{grid}.
Defaults to standard business cards.}

\item{inline}{\code{[logical(1)]} indicating whether knitr is called from \emph{inline} (\code{r 1+1}) or from a chunk.
Defaults to \code{FALSE}.}
}
\value{
A logical matrix of class \link{psGrid}.
}
\description{
Stores sorting grid as a logical \eqn{i * k} matrix with sorting columns as columns, sorting rows as rows and \code{TRUE} (allowed) or \code{FALSE} (not allowed) in cells.
}
\details{
\emph{Every} sort must have a grid.
Even a free distribution must have a grid, giving the maximum indices of rows and columns, but with all cells \code{TRUE}.
}
\section{Methods (by generic)}{
\itemize{
\item \code{validate_S3}: Validation

\item \code{as_psGrid}: Coercion from other vector forms

\item \code{as_psGrid}: Coercion from sort (sets all to \code{TRUE})

\item \code{knit_print}: Printing inside knitr chunks
}}

\section{Hexagonal tiling}{

\link{psGrid} and \link{psSort} store \emph{all} sorting grids as \emph{rectangular} matrices, using what is known as the \href{https://www.redblobgames.com/grids/hexagons/}{"offset" notation for hexagonal tiling}.
In offset notation, hexagonal tilings are saved as if they were normal (square) tilings, with an additional attribute giving which rows are to be offset.
In this way, both square and hexagonal tilings can be stored in a similar format.
They are also intuitive to use, where the outer limits of the tiling are rectangular, and rotation is not required, both of which are usually the case for sorting.
However, linear algebra operations are no longer defined on such hexagonal matrices in offset notation (that would require cube or axial coordinates).
Remember not to run such operations on hexagonally tiled \link{psGrid}s or \link{psSort}s.

The \code{offset} argument is used to switch between loosely defined tiling patterns.
Strictly speaking there are  \emph{three regular} tiling patterns: square, hexagonal and triangular.
However, items are more easily typeset in \emph{rectangles} than in squares, hexagons or triangles.
You can therefore also use "square" tiling (\code{offset = NULL}) for rectangulary set items, and even "hexagonal" tiling (\code{offset = "even"} or \code{offset = "odd"}) for rectangles (in a "brickwall" pattern) and irregular (stretched or squeezed) hexagons.
One combination remains impossible: you cannot have "square" tiling (\code{offset = NULL}) with hexagons (\code{polygon = 'hexagon'}).

The aspect ratio of the \emph{irregular} polygons is currently only provided to respective \code{knit_print()} methods.
To achieve \emph{regular} square and hexagonal tiling (though this is unlikely to be useful), set \code{aspect_ratio_cards} to \code{1}.

Notice that \code{offset} always refers to \emph{rows}, and as such implies hexagonal tiling in "\strong{pointy}"-topped rotation.

Remember that rows for \code{offset} are given using \emph{R} indices, starting with \code{1}.
Examples of offset notation in most other programming languages will differ."
}

\section{Printing in knitr chunks}{

Extends the \code{\link[knitr:knit_print]{knitr::knit_print()}} generic for pensieve S3 objects.

By default \code{print()} in knitr will default to \code{\link[knitr:knit_print]{knitr::knit_print()}}, so to nicely print some object \code{obj} inside a chunk, you can just write \code{print(obj)} or even just \code{obj}.

However, to manually invoke or preview the interactive displays in RStudio, you must call \code{\link[knitr:knit_print]{knitr::knit_print()}} in full.
The \code{\link[base:print]{base::print()}}ing method of the underlying classes is \emph{not} altered outside of a knitr chunk.
}

\examples{
# create simple grids ====

# make simple matrix by hand
m <- matrix(data = c(FALSE, TRUE, TRUE, TRUE, FALSE, TRUE), nrow = 2)
grid_byhand <- psGrid(grid = m)

# matrix with better dimnames
dimnames(m) <- list(
  c(NULL), # rows, or y-dimension is meaningless, used for ties
  desirable = NULL  # no use in adding actual column names
  # say, desirable is the short form for the sorting conditition used on x
)
grid_byhand <- psGrid(grid = m)

# coerce grid from conventional distribution notation
grid_bycoercion <- as_psGrid(obj = c(1,2,1))
}
\seealso{
Other S3 classes from `pensieve`: \code{\link{correlate}},
  \code{\link{extract}}, \code{\link{psClosedSorts}},
  \code{\link{psItemContent}}, \code{\link{psOpenSorts}},
  \code{\link{psOpenSort}}, \code{\link{psPeople}},
  \code{\link{score}}

Other print functions: \code{\link{psItemContent}}
}
\concept{S3 classes from `pensieve`}
\concept{print functions}
