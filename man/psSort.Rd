% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/psSort.R
\name{psSort}
\alias{psSort}
\alias{validate_S3.psSort}
\alias{as_psSort}
\alias{as_psSort.psGrid}
\alias{as_psSort.integer}
\alias{as_psSort.numeric}
\title{Store an \emph{individual} sort as a character matrix of \emph{item handles}}
\usage{
psSort(sort, desc_x = NULL, desc_y = NULL, polygon = "rectangle",
  offset = NULL)

\method{validate_S3}{psSort}(x, grid = NULL, items = NULL, ...)

as_psSort(obj, ...)

\method{as_psSort}{psGrid}(obj, ...)

\method{as_psSort}{integer}(obj, grid = NULL, ...)

\method{as_psSort}{numeric}(obj, grid = NULL, ...)
}
\arguments{
\item{sort}{\code{[matrix()]}
giving the occupying item of cells as \code{character(1)} strings of \strong{item handles}.
\code{NA} is used for empty \emph{and} disallowed cells (see \link{psGrid}).
At least one dimension should be named (see examples), or the x-axis (column names) is assumed to be the sorting direction.
Unnamed dimensions are assumed to be meaningless, i.e. used for stacking tied items.}

\item{desc_x, desc_y}{\code{[character(1)]}
giving a description of the sorting dimensions, such as the condition of instruction.
Defaults to \code{NULL}.
\code{desc_x} is for horizontal sorting across the columns.
\code{desc_y} is for (rarely used) vertical sorting across the rows.}

\item{polygon}{\code{[character(1)]} giving polygon to use for tiling

Must be one of:
\itemize{
\item \code{'rectangle'} (\strong{default}) or
\item \code{'hexagon'}
}}

\item{offset}{\code{[character(1)]} giving the \emph{rows} to be offset.

Must be one of:
\itemize{
\item \code{NULL} in which case no offset is used for a square tiling. (\strong{default})
\item \code{'even'} or
\item \code{'odd'}
}}

\item{x}{An object with one of the pensieve S3 classes.}

\item{grid}{\code{[matrix()]}
giving the availability of cells for sorting as \code{logical(1)} values.
At least one dimension should be named (see examples), or the x-axis (column names) is assumed to be the sorting direction.
Unnamed dimensions are assumed to be meaningless, i.e. used for stacking tied items.}

\item{items}{\code{[character()]} giving the \emph{participant-facing} \strong{item content}.
Can be named to provide short, \emph{researcher-facing} \strong{item handles}.
\itemize{
\item if \code{dir_bin} is \code{NULL} (default), \code{items} must be text.
Items can be marked up using \href{https://rmarkdown.rstudio.com/authoring_pandoc_markdown.html}{Pandoc Markdown}.
An additional subclass \code{psItemContentText} is prepended and validated.
\item if \code{dir_bin} is given, \code{items} must be file paths, relative from \code{dir_bin}.
An additional subclass \code{psItemContentBin`` is prepended and validated.}lang\code{,}fontsize_global\code{,}alignment\code{and}linestretch` are ignored.
}}

\item{...}{further arguments to be passed to methods.}

\item{obj}{An object which can be coerced to a character matrix of class \link{psSort}, currently one of:
\itemize{
\item a (named) integer(ish) vector, giving the x-axis item ranks per item (names are retained as item handles).
}}
}
\value{
A character matrix of class \link{psSort}.
}
\description{
Stores \emph{one} sort, by one participant as an \eqn{i * k} character matrix, with sorting columns as columns, sorting rows as rows and \emph{short item handles} (see \code{psItems}) in cells.
}
\details{
Sorts can be stored in the form in which they were originally created on a table or in a computer user interface.
The \code{y}-axis, though meaningless (ties) in most studies, is also stored, but this full matrix form makes it easy to reason about the data, and to validate it.
}
\section{Methods (by generic)}{
\itemize{
\item \code{validate_S3}: Validation

\item \code{as_psSort}: Coercion from \link{psGrid} (sets all to \code{NA})

\item \code{as_psSort}: Coercion from integer(ish) vector
}}

\section{Hexagonal tiling}{

\link{psGrid} and \link{psSort} store \emph{all} sorting grids as \emph{rectangular} matrices, using what is known as the \href{https://www.redblobgames.com/grids/hexagons/}{"offset" notation for hexagonal tiling}.
In offset notation, hexagonal tilings are saved as if they were normal (square) tilings, with an additional attribute giving which rows are to be offset.
In this way, both square and hexagonal tilings can be stored in a similar format.
They are also intuitive to use, where the outer limits of the tiling are rectangular, and rotation is not required, both of which are usually the case for sorting.
However, linear algebra operations are no longer defined on such hexagonal matrices in offset notation (that would require cube or axial coordinates).
Remember not to run such operations on hexagonally tiled \link{psGrid}s or \link{psSort}s.

The \code{offset} argument is used to switch between loosely defined tiling patterns.
Strictly speaking there are  \emph{three regular} tiling patterns: square, hexagonal and triangular.
However, items are more easily typeset in \emph{rectangles} than in squares, hexagons or triangles.
You can therefore also use "square" tiling (\code{offset = NULL}) for rectangulary set items, and even "hexagonal" tiling (\code{offset = "even"} or \code{offset = "odd"}) for rectangles (in a "brickwall" pattern) and irregular (stretched or squeezed) hexagons.
One combination remains impossible: you cannot have "square" tiling (\code{offset = NULL}) with hexagons (\code{polygon = 'hexagon'}).

The aspect ratio of the \emph{irregular} polygons is currently only provided to respective \code{knit_print()} methods.
To achieve \emph{regular} square and hexagonal tiling (though this is unlikely to be useful), set \code{aspect_ratio_cards} to \code{1}.

Notice that \code{offset} always refers to \emph{rows}, and as such implies hexagonal tiling in "\strong{pointy}"-topped rotation.

Remember that rows for \code{offset} are given using \emph{R} indices, starting with \code{1}.
Examples of offset notation in most other programming languages will differ."
}

\examples{
# create simple grids ====

# make simple matrix by hand
m <- matrix(data = c(FALSE, TRUE, TRUE, TRUE, FALSE, TRUE), nrow = 2)
grid_byhand <- psGrid(grid = m)

# matrix with better dimnames
dimnames(m) <- list(
  c(NULL), # rows, or y-dimension is meaningless, used for ties
  desirable = as.character(x = -1:1)
  # say, desirable is the short form for the sorting conditition used on x
)
grid_byhand <- psGrid(grid = m)

# coerce grid from conventional distribution notation
grid_bycoercion <- as_psGrid(obj = c(1,2,1))
one_sort <- matrix(
  data = c(NA, "live_2_work", NA, "work_2_live", NA, NA),
  nrow = 2,
  dimnames = list(
    c(NULL),
    # this is for rownames, of which there are none, because those are just ties
    desirable = as.character(-1:1)
    # 'desirable' is a short name for the description of the sorting axis
    # (here, as typically, x)
  )
)
one_sort <- psSort(sort = one_sort)

# you can coerce an empty (all `NA`) sort from grid
as_psSort(obj = grid_bycoercion)

# you can coerce a sort from an integer(ish) vector, with cells filled from the bottom up
one_sort_from_vec <- as_psSort(obj = c(foo = -1, bar = 0, zap = 1, zong = 1))
}
\concept{S3 classes from `pensieve`.}
